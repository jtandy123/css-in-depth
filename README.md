# CSS IN DEPTH

## 层叠
CSS里的C（代表cascade，层叠）

如何将特定样式应用到目标元素？

当声明冲突时，层叠会依据三种条件解决冲突：
- 样式表的来源：样式是从哪里来的，包括你的样式和浏览器默认样式等。
- 选择器优先级：哪些选择器比另一个选择器更重要。
- 源码顺序：样式表里的声明顺序。

![cascade-rules](https://github.com/jtandy123/images/blob/master/css/cascade-rules.png?raw=true)
  
### 样式来源
样式来源（优先级从低到高）：
- 用户代理样式，即浏览器默认样式
- 用户样式表，有些浏览器允许用户定义一个用户样式表，很少见
- 作者样式表
- 作者的!important

用户代理样式在不同浏览器上稍有差异，但是大体上是在做相同的事情：为标题（&lt;h1&gt;到&lt;h6&gt;）和段落（&lt;p&gt;）添加上下外边距，为列表（&lt;ol&gt;到&lt;ul&gt;）添加左侧内边距，为链接添加颜色，为元素设置各种默认字号。

### 优先级
如果无法用来源解决冲突声明，浏览器会尝试检查它们的优先级。浏览器将优先级分为两部分：HTML的行内样式和选择器的样式。

1. 行内样式：HTML的style属性写样式，这个声明只会作用于当前元素。行内样式没有选择器。
2. 选择器优先级:
- 如果选择器的ID数量更多，则它会胜出（即它更明确）
- 如果ID数量一致，那么拥有最多类的选择器胜出
- 如果以上两次比较都一致，那么拥有最多标签名的选择器胜出  
  
说明：伪类选择器（如:hover）和属性选择器（如[type="input"]）与一个类选择器的优先级相同。通用选择器（*）和组合器（>、+、~）对优先级没有影响。

优先级标记：  
一个常用的表示优先级的方式是用数值形式来标记，通常用逗号隔开每个数。比如，“1,2,2”表示选择器由1个ID、2个类、2个标签组成。优先级最高的ID列为第一位，紧接着是类，最后是标签。
有时还会用4个数的标记，其中将最重要的位置用0或1来表示，代表一个声明是否是用行内样式添加的。
  
通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。

### 源码顺序  
如果两个声明的来源和优先级相同，其中一个声明在样式表中出现较晚，或者位于页面较晚引入的样式表中，则该声明胜出。

实现相同的效果有很多途径。多想些实现方法，并思考每一种方法的利弊。面对一个样式问题，首先确定哪些声明可以实现效果。其次，思考可以用哪些选择器结构，然后选择最符合需求的那个。  

链接样式和源码顺序
```
a:link {
  color: blue;
  text-decoration: none;
}

a:visited {
  color: purple;
}

a:hover {
  text-decoration: underline;
}

a:active {
  color: red;
}
```
书写顺序之所以重要是因为层叠。优先级相同时，后出现的样式会覆盖先出现的样式。如果一个元素同时处于两个或者更多状态，最后一个状态就能覆盖其他状态。

层叠值：如果一个声明在层叠中“胜出”，它就被称作一个层叠值。元素的每个属性最多只有一个层叠值。

处理层叠时有两条通用的经验法则：
- 在选择器中不要使用ID。比较难覆盖，通常找不到另一个有意义的ID进行覆盖，于是就会复制原来的选择器，然后加上另一个类，以区别于想要覆盖的选择器。
- 不要使用!important。一旦引入一个!important，就会带来更多的!important
  
  
## 继承  
如果一个元素的某个属性没有层叠值，则可能会继承某个祖先元素的值。比如通常会给&lt;body&gt;元素加上font-family，里面的所有后代元素都会继承这个字体，就不必给页面的每个元素明确指定字体了。

默认情况下，只有特定的一些属性能被继承，它们主要是：
- 文本相关的属性：color、font、font-family、font-size、font-weight、font-variant、font-style、line-height、letter-spacing、text-align、text-indent、text-transform、white-space以及word-spacing。
- 列表属性：list-style、list-style-type、list-style-position以及list-style-image。
- 表格的边框属性：border-collapse、border-spacing。

继承属性会顺序传递给后代元素，直到它被层叠值覆盖。

## 特殊值  
有两个特殊值可以赋给任意属性，用于控制层叠：inherit和initial。  
- inherit：元素会继承其父元素的值。还可以使用inherit关键字强制继承一个通常不会被继承的属性，比如边框和内边距。通常在实践中很少这么做。
- initial: 撤销作用于某个元素的样式。每一个CSS属性都有初始（默认）值。如果将initial值赋给某个属性，那么就会有效地将其重置为默认值，这种操作相当于硬复位了该值。initial重置为属性的初始值，而不是元素的初始值。

例如：
border: initial等价于border: none  
width: initial等价于width: auto
display: initial等价于display: inline

## 简写属性  
用于同时给多个属性赋值的属性。
- font: font-style font-variant font-weight font-size/line-height font-family
- background: background-color background-position background-size background-repeat background-origin background-clip background-attachment background-image
- border: border-width border-style border-color
- border-width: 上右下左
```
font: italic bold 18px/1.2 "Helvetica", "Arial", sans-serif;
```
简写属性会默默覆盖其他样式：大多简写属性可以省略一些值，只指定关注的值。省略的值会被隐式地设置为初始值。会默默覆盖在其他地方定义的样式。
在所有简写属性里，font的问题最严重，要避免在&lt;body&gt;元素的通用样式以外使用font。  

简写值的顺序：
- 上、右、下、左：margin、padding等，时钟顺时针
- 水平、垂直：background-position、box-shadow、text-shadow等，笛卡尔网格
---

## 相对单位

响应式：在CSS中指的是样式能够根据浏览器窗口的大小有不同的“响应”。  
绝对长度单位：
- px
- mm
- cm
- in
- pt（点，印刷术语，1/72英寸）
- pc（派卡，印刷术语，12点）  
  
1 in = 25.4 mm = 2.54cm = 6 pc = 72 pt = 96 px  
16 px = 12 pt  
设计师经常用点作为单位，开发人员则习惯用像素  

浏览器会根据相对单位的值计算出绝对值，称作计算值。
- em, 1em等于当前元素的字号，其准确值取决于作用的元素  
- rem  

### em
当设置padding、height、width、border-radius等属性时，使用em会很方便。当元素继承了不同的字号，或者用户改变了字体设置时，这些属性会跟着元素均匀地缩放。 

当font-size使用em声明时，会根据继承的字号来计算绝对字号。  

如果知道字号的像素值，但是想用 em 声明，可以用一个简单的公式换算：用想要的像素大小除以父级（继承）的像素字号。比如，想要一个 10px 的字体，元素继承的字体是 12px，则计算结果是 10/12 = 0.8333em。如果想要一个 16px 的字体，父级字号为 12px，则计算结果是 16/12 = 1.3333em。  

对大多数浏览器来说，默认的字号为 16px。准确地说，medium 关键字的值是 16px。  

- em同时用于字号和其他属性
   - 用 em 定义了字号（基于继承的字号）
   - 用 em 定义了其他属性，比如
padding 和 border-radius（基于当前元素的字号）。  

em 的复杂之处在于同时用它指定一个元素的字号和其他属性。这时，浏览器必须先计算字号，然后使用这个计算值去算出其余的属性值。这两类属性可以拥有一样的声明值，但是计算值不一样。

- 字体缩小问题：当用 em 来指定多重嵌套的元素的字号时，文字会放大或者缩小。
```
body {
 font-size: 16px;
}
ul {
 font-size: .8em;
} 

<ul>
 <li>Top level
  <ul>
   <li>Second level
    <ul>
     <li>Third level
      <ul>
       <li>Fourth level
        <ul>
         <li>Fifth level</li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>
```
解决办法：嵌套的列表应当跟其父级的字号一致
```
ul {
 font-size: .8em;
}
ul ul {
 font-size: 1em;
} 
```

### rem
根节点是所有其他元素的祖先节点。根节点有一个伪类选择器（:root），可以用来选中它自己。  
rem 是 root em 的缩写。rem 不是相对于当前元素，而是相对于根元素的单位。不管在文档的什么位置使用 rem，1.2rem 都会有相同的计算值：1.2 乘以根元素的字号。  

一般会用 rem 设置字号，用 px 设置边框，用 em 设置其他大部分属性，尤其是内边距、外边距和圆角（有时用百分比设置容器宽度）。

### 停止像素思维
- 设置一个合理的默认字号
- 构造响应式面板：可以根据屏幕尺寸，用媒体查询改变根元素的字号
- 缩放单个组件：父元素的字号用rem表示，子元素样式用em定义，用class改变父元素的字号，组件内所有的大小都是相对于父元素的字号，改变了父元素的字号后，整个组件的大小都会改变。

> 媒体查询，即@media 规则，可以指定某种屏幕尺寸或者媒体类型（比如，打印机或者屏幕）下的样式。这是响应式设计的关键部分。

### 视口的相对单位
em和rem都是相对于font-size定义的。
> 视口——浏览器窗口里网页可见部分的边框区域。它不包括浏览器的地址栏、工具栏、状态栏。
- vh: 视口高度的 1/100
- vw: 视口宽度的 1/100
- vmin: 视口宽、高中较小的一方的 1/100（IE9 中叫 vm，而不是 vmin）
- vmax: 视口宽、高中较大的一方的 1/100（IE11不支持vmax，Edge支持vmax）

> CSS3: “3”是一个非正式的版本号，其实并没有 CSS3 规范，而是 CSS 规范分成了单独的模块，每个模块单独管理版本。如今背景和边框的规范脱离了盒模型模块以及层叠和继承模块。这样W3C 就能够制定 CSS 某个领域的新版本，而不需要更新其他没变的领域。很多规范仍然停留在版本 3（现在称作 level 3），但是有一些规范已经处于 level 4，比如选择器规范。还有一些规范处于 level 1，比如 Flexbox。

- 使用vw定义字号：元素能够在两种视口大小之间平滑地过度，不会在某个断点突然改变。当视口大小改变时，元素会逐渐过渡。
- 使用calc()定义字号：可以对两个及其以上的值进行基本运算。它支持的运算包括：加（+）、减（−）、乘（×）、除（÷）。加号和减号两边必须有空白。
```
/*
慢慢缩放浏览器，字体会平滑地缩放。0.5em 保证了最小字号，1vw 则确保了字体会随着视口流畅地缩放。
*/
:root {
  font-size: calc(0.5em + 1vw);
}
```

### 无单位的数值和行高
有些属性允许无单位的值（即一个不指定单位的数）。支持这种值的属性包括 line-height、z-index、font-weight（700 等于 bold，400 等于 normal，等等）。任何长度单位（如 px、em、rem）都可以用无单位的值 0，因为这些情况下单位不影响计算值，即 0px、0%、0em 均相等。  
注意：一个无单位的 0 只能用于长度值和百分比，比如内边距、边框和宽度等，而不能用于角度值，比如度，或者时间相关的值，比如秒。

line-height 属性比较特殊，它的值既可以有单位也可以无单位。通常应该使用无单位的数值，因为它们继承的方式不一样。无单位的数值继承声明值，在子元素上重新计算；有单位的数值继承计算值，在父元素上计算之后再继承

当一个元素的值定义为长度（px、em、rem，等等）时，子元素会继承它的计算值。当使用 em 等单位定义行高时，它们的值是计算值，传递到了任何继承子元素上。如果子元素有不同的字号，并且继承了 line-height 属性，就会造成意想不到的结果，比如文字重叠。  

> 长度——一种用于测量距离的 CSS 值的正式称谓。它由一个数值和一个单位组成，比如 5px。长度有两种类型：绝对长度和相对长度。百分比类似于长度，但是严格来讲，它不是长度。  

使用无单位的数值时，继承的是声明值，即在每个继承子元素上会重新算它的计算值。  

### 自定义属性（即CSS变量）  
Custom Properties for Cascading Variables  层叠变量的自定义属性   
IE11不支持自定义属性   
```
:root {
  --main-font: Helvetica, Arial, sans-serif;
  --brand-color: #369;
}

p {
  font-family: var(--main-font, sans-serif);
  color: var(--secondary-color, blue); /* secondary-color变量没有定义，会使用备用值blue */
}
```
说明 如果 var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。比如，如果在 padding: var(--brand-color)中的变量算出来是一个颜色，它就是一个非法的内边距值。这种情况下，内边距会设置为 0。

#### 动态改变自定义属性
自定义属性的真正意义在于：自定义属性的声明能够层叠和继承，可以在多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。自定义属性就像作用域变量一样，它的值会被后代元素继承。   
- 首先还是在:root 选择器的规则集中定义变量。这些值就可以提供给根元素（整个网页）下的任何元素。当根元素的后代元素使用这个变量时，就会解析这里的值。
- 自定义属性就像作用域变量一样，它的值会被后代元素继承。在根元素的后代元素选择器中重新定义变量，覆盖根元素选择器中定义的变量

#### 使用JavaScript改变自定义属性
```
<script type="text/javascript">
  var rootElement = document.documentElement;
  var styles = getComputedStyle(rootElement);
  var mainColor = styles.getPropertyValue('--main-bg');
  console.log(String(mainColor).trim());

  rootElement.style.setProperty('--main-bg', '#cdf');
</script>
```
利用这种技术，就可以用 JavaScript 实时切换网站主题，或者在网页中突出显示某些元素，或者实时改变任意多个元素。只需要几行 JavaScript 代码，就可以进行更改，从而影响网页上的大量元素。   

在不支持自定义属性的浏览器上，任何使用 var()的声明都会被忽略。尽量为这些浏览器提供回退方案。
```
color: black;
color: var(--main-color);
```

总结：
- 拥抱相对单位，让网页的结构决定样式的含义。
- 建议用rem设置字号，但是有选择地用em实现网页组件的简单缩放。
- 不用媒体查询也能让整个网页响应式缩放。
- 使用无单位的值设置行高。
- 请开始熟悉CSS的一个新特性：自定义属性。

--- 

## 盒模型
- 设置元素大小
- 垂直居中
- 等高列
- 负的外边距和外边距折叠
- 网页组件之间一致的间距

浏览器是如何设置元素的大小和位置的。高级的布局话题基于文档流和盒模型等概念，这些是决定网页元素的大小和位置的基本规则。  

### 元素宽度的问题
IE有一个bug，它会默认将&lt;main&gt;元素渲染成行内元素，而不是块级元素，用声明 display: block 来纠正。   

两列对齐：
```
.main {
 float: left;
 width: 70%;
 background-color: #fff;
 border-radius: .5em;
}
.sidebar {
 float: left;
 width: 30%;
 padding: 1.5em;
 background-color: #fff;
 border-radius: .5em;
} 
```
使用浮动布局，将两列向左浮动，然后将两列宽度设置为 70%和 30%，但它们总共占据的宽度超过了可用空间的 100%，这是因为盒模型的默认行为。当给一个元素设置宽或高的时候，指定的是内容的宽或高，所有内边距、边框、外边距都是追加到该宽度上的。
- 魔术值，通过改样式试出来的值
- calc，让浏览器计算
- 用box-sizing调整盒模型
> box-sizing 的默认值为 content-box，任何指定的宽或高都只会设置内容盒子的大小。将 box-sizing 设置为 border-box 后，height 和 width 属性会设置内容、内边距以及边框的大小总和。

全局设置border-box
```
*,
::before,
::after {
  box-sizing: border-box;
}
```
加上这段代码，height 和 width 会指定元素的实际宽和高。改变内边距不会影响它们。

如果在网页中使用了带样式的第三方组件，就可能会因此破坏其中一些组件的布局，尤其是当第三方组件在开发 CSS 的过程中没有考虑到使用者会修改盒模型时。因为全局设置border-box 时使用的通用选择器会选中第三方组件内的每个元素，修改盒模型可能会有问题，所以最终需要写另外的样式将组件内的元素恢复为 content-box。   
利用继承改一下修改盒模型的方式：
```
:root {
  box-sizing: border-box;
}

*,
::before,
::after {
  box-sizing: inherit;
}

.third-party-component {
  box-sizing: content-box;
}
```
给列之间加上间隔：使用em（em单位的一致性更好）指定间距，使用calc()从宽度中减去间距。
```
.main {
 float: left;
 width: 70%;
 background-color: #fff;
 border-radius: .5em;
}
.sidebar {
 float: left;
 width: calc(30% - 1.5em);
 margin-left: 1.5em;
 padding: 1.5em;
 background-color: #fff;
 border-radius: .5em;
} 
```

### 元素高度问题
对 border-box 的修改依然适用于高度，而且很有用，但是通常最好避免给元素指定明确的高度。普通文档流是为限定的宽度和无限的高度设计的。内容会填满视口的宽度，然后在必要的时候折行。因此，容器的高度由内容天然地决定，而不是容器自己决定。
> 普通文档流 —— 指的是网页元素的默认布局行为。行内元素跟随文字的方向从左到右排列，当到达容器边缘时会换行。块级元素会占据完整的一行，前后都有换行。

#### 控制溢出行为
当明确设置一个元素的高度时，内容可能会溢出容器。当内容在限定区域放不下，渲染到父元素外面时，就会发生这种现象。文档流不考虑溢出的情况，其容器下方的任何内容都会渲染到溢出内容的上面。   
用 overflow 属性可以控制溢出内容的行为，该属性支持以下 4 个值：
- visible（默认值）——所有内容可见，即使溢出容器边缘。
- hidden——溢出容器内边距边缘的内容被裁剪，无法看见。
- scroll——容器出现滚动条，用户可以通过滚动查看剩余内容。在一些操作系统上，会
出现水平和垂直两种滚动条，即使所有内容都可见（不溢出）。不过，在这种情况下，滚
动条不可滚动（置灰）。
- auto——只有内容溢出时容器才会出现滚动条。

通常情况下，我倾向于使用 auto 而不是 scroll，因为在大多数情况下，我不希望滚动条一直出现。请谨慎地使用滚动条。浏览器给网页最外层加上了滚动条，如果网页内部再嵌套滚动区域，用户就会很反感。如果用户使用鼠标滚轮滚动网页，当鼠标到达一个较小的滚动区域，滚轮就会停止滚动网页，转而滚动较小的区域。
   
除了垂直溢出，内容也可能在水平方向溢出。溢出的规则跟垂直方向上的一致。可以用 overflow-x 属性单独控制水平方向的溢出，或者用 overflow-y 控制垂直方向溢出。这些属性支持overflow 的所有值，然而同时给 x 和 y 指定不同的值，往往会产生难以预料的结果。

#### 百分比高度的备选方案
用百分比指定高度存在问题。百分比参考的是元素容器块的大小，但是容器的高度通常是由子元素的高度决定的。这样会造成死循环，浏览器处理不了，因此它会忽略这个声明。要想让百分比高度生效，必须给父元素明确定义一个高度。

##### 等高列
21 世纪初，CSS 取代了 HTML 表格成为布局的主要方式。当时表格是实现等高列的唯一方式，更具体地说，是不明确指定高度就能实现等高列的唯一方式。   
现代浏览器支持了 CSS 表格，可以轻松实现等高列，比如 IE8+支持 display: table，IE10+支持弹性盒子或者 Flexbox，都默认支持等高列。
   
任意一列的内容增加，两列的高度都会增加， 同时保持底部对齐。   
最好的办法是让它们自己决定高度，然后扩展较矮的列，让它的高度等于较高的列。
   
CSS表格布局 - 实现两列等高布局
- 用 CSS 表格布局替代浮动布局。给容器设置 display: table，给每一列设置 display: table-cell。
- 默认情况下，显示为 table 的元素宽度不会扩展到 100%，因此需要 明确指定宽度。
- margin不会作用于table-cell元素。可以用表格元素的 border-spacing 属性来定义单元格的间距。该属性接受两个长度值: 水平间距和垂直间距。
- 负外边距，给整个表格包裹一层新的容器，将其左右外边距设置为负值，从而抵消表格容器外侧的border-spacing。
正的外边距会将容器的边缘往里推，而负的外边距则会将边缘往外拉。
   
- HTML表格&lt;table&gt;实现布局：HTML表格的colspan和rowspan属性在CSS中没有可替代的方案
- 浮动布局
- CSS表格布局
- flexbox布局

Flexbox - 实现两列等高布局
如果不用支持IE9及其以下的浏览器，建议使用Flexbox而不是表格布局
- 将容器的display属性设置为flex，子元素默认等高
- 弹性容器内的元素不需要指定display或者float属性
- 跟浮动布局一样，外边距可以生效
除非别无选择，否则不要明确设置元素的高度。设置高度一定会导致更复杂的情况
   
垂直居中内容
- vertical-align声明只会影响行内元素或者table-cell元素，对块级元素不生效。
- 对于行内元素，它控制着该元素跟同一行内其他元素之间的对齐关系。比如，可以用它控制一个行内的图片跟相邻的文字对齐。
- 对于显示为table-cell的元素，vertical-align控制了内容在单元格内的对齐。如果页面用了CSS表格布局，那么可以用vertical-align来实现垂直居中。

垂直居中指南：
- 可以用一个自然高度的容器吗?给容器加上相等的上下内边距让内容居中。
- 容器需要指定高度或者避免使用内边距吗?对容器使用display: table-cell和vertical-align: middle。
- 可以用Flexbox吗? 如果不需要支持 IE9，可以用 Flexbox 居中内容。
- 容器里面的内容只有一行文字吗?设置一个大的行高，让它等于理想的容器高度。这样会让容器高度扩展到能够容纳行高。如果内容不是行内元素，可以设置为 inline-block。
- 容器和内容的高度都知道吗?将内容绝对定位。(只有当前面提到的方法都无效时才推荐这种方式。)
- 不知道内部元素的高度?用绝对定位结合变形(transform)。(只有当前面提到的方法都无效时才推荐该方法。)

howtocenterincss网站：http://howtocenterincss.com/

### 负外边距
- 不同于内边距和边框宽度，外边距可以设置为负值。
- 如果设置左边或顶部的负外边距，元素就会相应地向左或向上移动，导致元素与它前面的元素重叠
- 如果设置右边或者底部的负外边距，并不会移动元素，而是将它后面的元素拉过来。
- 给元素底部加上负外边距并不等同于给它下面的元素顶部加上负外边距。
- 如果不给一个块级元素指定宽度，它会自然地填充容器的宽度。但如果在右边加上负外边距，则会把它拉出容器。如果在左边再加上相等的负外边距，元素的两边都会扩展到容器外面。
- 如果元素被别的元素遮挡， 利用负外边距让元素重叠的做法可能导致元素不可点击。

### 外边距折叠
- 当顶部和/或底部的外边距相邻时，就会重叠，产生单个外边距。这种现象被称作折叠。
- 外边距折叠的主要原因与包含文字的块之间的间隔相关。
- 文字折叠
  - 折叠外边距的大小等于相邻外边距中的最大值。
- 多个外边距折叠
  - 即使两个元素不是相邻的兄弟节点也会产生外边距折叠。在没有其他CSS的影响下，所有相邻的顶部和底部外边距都会折叠。
  - 所有相邻的顶部和底部外边距会折叠到一起。如果在页面中添加一个空的、无样式的div(没有高度、边框和内边距)，它自己的顶部和底部外边距就会折叠。
  - 只有上下外边距会产生折叠，左右外边距不会折叠。
- 外边距在容器外部折叠
  - 弹性子元素的外边距不会折叠
  - 给头部添加上下内边距，外边距就不会在容器外部折叠。

防止外边距折叠：
- 对容器使用 overflow: auto(或者非 visible 的值)，防止内部元素的外边距跟容器外部的外边距折叠。这种方式副作用最小。
- 在两个外边距之间加上边框或者内边距，防止它们折叠。
- 如果容器为浮动元素、内联块、绝对定位或固定定位时，外边距不会在它外面折叠。
- 当使用 Flexbox 布局时，弹性布局内的元素之间不会发生外边距折叠。网格布局同理。
- 当元素显示为table-cell时不具备外边距属性，因此它们不会折叠。此外还有table-row和大部分其他表格显示类型，但不包括 table、table-inline、table-caption。

### 容器内元素间距
容器的内边距与容器内元素的外边距接触产生大于其余方向的留白   
如何确保每个元素之间有间距，但是容器顶部（或底部）没有多余的间距：
- 猫头鹰选择器（lobotomized owl selector，* + *）：它会选中页面上有着相同 父级的非第一个子元素。
- 通用选择器（*）的性能问题：在IE6中，这个选择器超级慢
- 使用猫头鹰选择器是需要权衡的。它省去了许多的需要设置外边距的地方，但是在某些不想加外边距的地方则需要覆盖。
- 通常只在有并列元素，或者有多列布局时这样使用。有时还需要根据设计，给段落和标题设置特定的外边距。

### 盒模型总结
- 总是全局设置 border-box，以便得到预期的元素大小。
- 避免明确设置元素的高度，以免出现溢出问题。
- 使用现代的布局技术，比如 display: table 或者 Flexbox 实现列等高或者垂直居中内容。
- 如果外边距的行为很奇怪，就采取措施防止外边距折叠。
- 使用猫头鹰选择器全局设置堆叠元素之间的外边距。

## 浮动
三种改变文档流的方式：
- 浮动
- Flexbox
- 网格布局

定位：将元素堆叠到其他元素之上

常见的网页布局模式：
- 双容器模式
- 媒体对象

浮动能将一个元素(通常是一张图片)拉到其容器的一侧，这样文档流就能够包围它。这种布局在报纸和杂志中很常见，因此CSS增加了浮动来实现这种效果。      
浮动元素会被移出正常文档流，并被拉到容器边缘。文档流会重新排列，但是它会包围浮动元素此刻所占据的空间。如果让多个元 素向同侧浮动，它们就会挨着排列。   
> 在CSS早期，开发人员发现使用简单的浮动就可以移动页面的各个部分，从而实现各种各样的布局。浮动本身不是为了实现页面布局而设计的，但是在近20年的时间里，我们把它当成了布局工具。之所以这样做是因为它是那个年代唯一的选择。后来，display: inline-block 和 display: table 的问世才让我们有了别的方案，尽管二者可替代的场景有限。Flexbox和网格布局最近几年才出现，在它们出现之前，浮动一直承担着页面布局的重任。
   
通常，最简单的方式是先将网页的大块区域布局好，再逐级布局内部的小元素。   
在开始浮动元素前，要先将网页的外层结构样式写好。   
   
双容器模式（double container pattern）：通过将内容放置到两个嵌套的容器中，然后给内层的容器设置外边距，让它在外层容器中居中。

是否还有必要学习浮动？
- 在现代浏览器中，不用浮动也能比过去更好地实现布局，甚至可以完全弃用浮动。
- 但是如果要支持IE浏览器，现在放弃浮动还为时过早。只有 IE10 和 IE11 支持Flexbox，而且还有一些bug。如果不想碰到bug，或者需要支持旧版浏览器，浮动也许是更好的选择。
- 如果你在支持旧代码库，它很可能用到了浮动布局。为了维护旧代码，也需要了解浮动的工作原理。
- 浮动布局通常不需要那么多的标记，新的布局方法则需要添加额外的容器元素。如果你写样式时不允许修改标记，浮动更能满足你的需求。
- 要实现将图片移动到网页一侧，并且让文字围绕图片的效果，浮动仍然是唯一的方法。

### 容器折叠和清楚浮动
#### 容器折叠
- 浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。
- 浮动是为了实现文字围绕浮动元素排列的效果。在段落里浮动图片时，段落的高度并不会增长到能够容纳该图片。也就是说，如果图片比段落文字高，下一段会直接从上一段的文字下面开始，两段文字都会围绕浮动的图片排列。
- 一个解决办法是使用跟浮动配套的 clear 属性。将一个元素放在主容器的末尾，并对它使用 clear，这会让容器扩展到浮动元素下面。
- clear: both 声明让该元素移动到浮动元素的下面，而不是侧面。
- clear 的值还可以设置为 left 或者 right，这样只会相应地清除向左或者向右浮动的元素。因为空 div 本身没有浮动，所以容器就会扩展，直到包含它，因此也会包含该 div 上面的浮动元素。
- 不用额外的 div 标签，我们还可以用伪元素(pseudo-element)来实现。使用::after 伪元素选择器，就可以快速地在 DOM 中在容器末尾添加一个元素，而不用在 HTML 里添加标记。
> 伪元素——一种特殊的选择器，可以选中文档的特定部分。伪元素以双冒号(::) 开头，大部分浏览器为了向后兼容也支持单冒号的形式。最常见的伪元素是::before和::after，用来向元素的开始或者结束位置插入内容。
清除浮动（clearfix）,简称为cf，正好还能表示“包含浮动”(contain float)   
```css
.clearfix::after { /* 选中容器末尾的伪元素 */
  display: block; /* 将伪元素的display设置为非inline */
  /* content的值包含了空格。空字符串("")也能生效，但是在旧版的Opera浏览器中有个隐藏的 bug，需要添加一个空格字符才能解决。*/
  content: " "; /* 给定一个content值，以便让伪元素出现在文档中 */
  clear: both; /* 让伪元素清楚容器中的所有浮动 */
}
```
要给包含浮动的元素清除浮动，而不是给别的元素，比如浮动元素本身，或包含浮动的元素后面的兄弟元素。   

清除浮动的一致性问题：浮动元素的外边距不会折叠到清除浮动容器的外 部，非浮动元素的外边距则会正常折叠。      
清除浮动的一个修改版，它能包含所有的外边距：
```css
.clearfix::before, /* 让::before和::after伪元素都显示出来 */
.clearfix::after {
  display: table; /* 防止伪元素的外边距折叠 */
  content: " ";
}
.clearfix::after {
  clear: both; /* 只有::after伪元素需要清除浮动 */
}
```
clear属性只能对块级元素生效。表格是块级元素，但是单元格并不是。因此，clear属性无法跟 display: table-cell 一起使用。所以要用 display: table 来清除浮动，同时利用隐式创建单元格来包含外边距。
   
浮动陷阱：
- 浏览器会将浮动元素尽可能地放在靠上的地方
清除每行浮动的技术要求知道每行有几个元素。如果宽度不是通过百分比来定义的，那么随着视口宽度的改变，每行的元素个数可能会变化。这种情况下，最好使用别的布局方案，比如 Flexbox 或者 inline-block 元素。

媒体对象：让图片在一侧，一段文字出现在图片的旁边的布局

建立一个块级格式化上下文(block formatting context， BFC)
BFC 是网页的一块区域，元素基于这块区域布局。它将内部的内容与外部的上下文隔离开。这种隔离为创建 BFC 的元素做出了以下 3 件事情。
- 包含了内部所有元素的上下外边距。它们不会跟 BFC 外面的元素产生外边距折叠。
- 包含了内部所有的浮动元素。
- 不会跟 BFC 外面的浮动元素重叠。
BFC 里的内容不会跟外部的元素重叠或者相互影响。如果给元素增加 clear 属性，它只会清除自身所在 BFC 内的浮动。如果强制给一个元素生成一个新的 BFC，它不会跟其 他 BFC 重叠。   
给元素添加以下的任意属性值都会创建 BFC:
- float: left 或 right，不为 none 即可。
- overflow:hidden、auto 或 scroll，不为 visible 即可。
- display:inline-block、table-cell、table-caption、flex、inline-flex、grid 或 inline-grid。拥有这些属性的元素称为块级容器(block container)。
- position:absolute 或 position: fixed。

网页的根元素也创建了一个顶级的 BFC。
  
- 使用 overflow: auto 通常是创建 BFC 最简单的一种方式。
- 使用浮动或者 inline-block 方式创建 BFC 的元素宽度会变成 100%，因此需要限制一下元素的宽度，防止因为过宽而换行。
- 使用 table-cell 方式显示的元素，其宽度只会刚好容纳其中的内容，因此需要设置一个较大的宽度，强制使其填满剩余空间。
> 某些情况下，BFC 中的内容可能还会与别的 BFC 的内容重叠。比如，内容溢出 了容器(比如内容太宽)或者因为负外边距导致内容被拉到容器外面。

#### 网格系统
- 借助网格系统提高代码的可复用性。
- 网格系统提供了一系列的类名，可添加到标记中，将网页的一部分构造成行和列。
- 它应该只给容器设置宽度和定位，不给网页提供视觉样式，比如颜色和边框。需要在每个容器内部添加新的元素来实现想要的视觉样式。

网格系统的设计思想:在一个行容器里放置一个或多个列容器。列容器的类决定每列的宽度。
> CSS 框架——一个预编译的 CSS 代码库，提供了 Web 开发中常见的样式模式。它能够帮助快速搭建原型或者提供一个稳定的样式基础，辅助构建新样式。常见的框架包括 Bootstrap、Foundation 以及 Pure。

通常网格系统的每行被划分为特定数量的列， 一般是 12 个，但也可以是其他数。每行子元素的宽度可能等于 1~12 个列的宽度。   
选取 12 作为列数是因为它能够被 2、3、4、6 整除，组合起来足够灵活。  
每行有一个行容器 div，在其中用 column-n 类 为每个列元素放置一个 div(n 是网格里的列数)。  
```html
<div class="row">
  <div class="column-4">4 column</div>
  <div class="column-8">8 column</div>
</div>
```
   
```css
    .row {
      margin-left: -0.75em;
      margin-right: -0.75em;
    }

    .row::after { /* 行元素的作用就是给列元素提供一个容器，将列元素包裹起来，清除浮动恰好能起到这个作用 */
      content: " ";
      display: block;
      clear: both;
    }

    /* 将所有的列都浮动到左边，给每种列元素指定宽度值。 */
    [class*="column-"] { /* *=比较符可以匹配任意包含指定字符串的值 */
      float: left;
      margin-top: 0;
      padding: 0 0.75em;
    }

    .column-1 {width: 8.3333%;}
    .column-2 {width: 16.6667%;}
    .column-3 {width: 25%;}
    .column-4 {width: 33.3333%;}
    .column-5 {width: 41.6667%;}
    .column-6 {width: 50%;}
    .column-7 {width: 58.3333%;}
    .column-8 {width: 66.6667%;}
    .column-9 {width: 75%;}
    .column-10 {width: 83.3333%;}
    .column-11 {width: 91.6667%;}
    .column-12 {width: 100%;}
```

总结：
- 浮动的设计初衷是让文字围绕一个元素排列，但有时这种效果并不是我们想要的。
- 使用清除浮动来包含浮动元素。
- BFC 有 3 个好处:包含浮动元素，防止外边距折叠，防止文档流围绕浮动元素排列。
- 使用双容器模式让页面内容居中。
- 使用媒体对象模式将描述文字定位到图片旁边。
- 使用网格系统实现更丰富的网页布局。

## Flexbox





